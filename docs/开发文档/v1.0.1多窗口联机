# **BongoPet 多窗口联机技术实现方案**

## **核心架构设计**

### **多窗口架构模式**
```
主窗口 (本地用户)
├── Live2D 渲染 (自己的小猫)
├── 网络管理器 (房主时包含服务器)
├── 窗口管理器 (管理所有远程用户窗口)
└── 事件分发器

远程用户窗口1 (用户A的小猫)
├── Live2D 渲染 (用户A的小猫)
├── 网络事件接收器
└── 状态同步器

远程用户窗口2 (用户B的小猫)
├── Live2D 渲染 (用户B的小猫)
├── 网络事件接收器
└── 状态同步器

... (更多远程用户窗口)
```

### **窗口生命周期管理**
```
用户加入房间 → 创建新窗口 → 加载对应模型 → 开始状态同步
用户离开房间 → 停止状态同步 → 销毁窗口 → 清理资源
```

## **详细技术实现路线**

### **第一阶段：Tauri多窗口系统**

#### **1.1 窗口管理架构**
- **主窗口职责**：
  - 渲染本地用户的小猫
  - 管理网络连接（房主时运行服务器）
  - 管理所有远程用户窗口的创建/销毁
  - 作为事件分发中心

- **远程用户窗口职责**：
  - 仅渲染对应远程用户的小猫
  - 接收该用户的状态更新
  - 处理该用户的输入事件
  - 支持用户拖动和个性化设置

#### **1.2 窗口创建策略**
- **窗口标识系统**：
  - 每个用户分配唯一的 `userId`
  - 窗口标签格式：`remote-user-{userId}`
  - 窗口标题显示用户名和模型信息

- **窗口属性配置**：
  - 透明背景，无边框装饰
  - 始终置顶，但优先级低于主窗口
  - 可拖动，可调整大小
  - 独立的任务栏图标（可选）

### **第二阶段：窗口间通信系统**

#### **2.1 事件分发机制**
- **中心化事件分发**：
```
网络事件接收 → 主窗口事件分发器 → 根据userId路由 → 对应用户窗口
```

- **事件类型分类**：
  - **用户管理事件**：加入/离开房间 → 主窗口处理
  - **状态同步事件**：位置/动画更新 → 对应用户窗口
  - **输入事件**：键盘按键 → 对应用户窗口
  - **全局事件**：房间解散 → 所有窗口

#### **2.2 窗口通信协议**
- **Tauri事件系统**：
  - 使用 `emit_to()` 向特定窗口发送事件
  - 使用 `emit_all()` 广播全局事件
  - 实现窗口间的双向通信

- **消息格式设计**：
```typescript
interface WindowMessage {
  type: 'user_state' | 'user_input' | 'user_join' | 'user_leave' | 'room_close',
  userId: string,
  data: any,
  timestamp: number
}
```

### **第三阶段：动态窗口管理**

#### **3.1 窗口创建流程**
- **新用户加入处理**：
  1. 主窗口接收 `user_joined` 网络事件
  2. 检查是否已存在该用户窗口
  3. 创建新的远程用户窗口
  4. 传递用户信息到新窗口
  5. 新窗口初始化Live2D模型
  6. 开始接收该用户的状态同步

- **窗口初始化参数**：
```rust
WebviewWindowBuilder::new(
    app,
    format!("remote-user-{}", user_info.id),
    WebviewUrl::App("/remote-user".into())
)
.title(&format!("{} - {}", user_info.name, user_info.model_id))
.inner_size(300.0, 400.0)
.min_inner_size(200.0, 250.0)
.decorations(false)
.transparent(true)
.always_on_top(true)
.skip_taskbar(false)
.build()?
```

#### **3.2 窗口销毁流程**
- **用户离开处理**：
  1. 主窗口接收 `user_left` 网络事件
  2. 向对应用户窗口发送关闭通知
  3. 用户窗口保存状态并清理资源
  4. 主窗口销毁用户窗口
  5. 更新窗口管理器状态

- **优雅关闭机制**：
  - 播放离开动画（如果有）
  - 保存窗口位置和大小
  - 清理Live2D资源
  - 取消网络事件监听

### **第四阶段：窗口状态管理**

#### **4.1 窗口位置持久化**
- **位置保存策略**：
  - 每个用户窗口的位置独立保存
  - 支持跨会话恢复窗口位置
  - 处理多显示器场景

- **存储结构**：
```typescript
interface WindowState {
  userId: string,
  userName: string,
  position: { x: number, y: number },
  size: { width: number, height: number },
  display: number, // 显示器编号
  lastSeen: number // 上次见到该用户的时间
}
```

#### **4.2 智能窗口布局**
- **初始位置算法**：
  - 新用户窗口避免与现有窗口重叠
  - 优先在主显示器上排列
  - 螺旋式或网格式布局算法

- **动态调整机制**：
  - 检测窗口重叠并自动调整
  - 支持用户手动重置布局
  - 屏幕分辨率变化时的适配

### **第五阶段：增强用户体验**

#### **5.1 窗口个性化功能**
- **右键菜单**：
  - 临时隐藏/显示窗口
  - 锁定窗口位置
  - 调整透明度
  - 查看用户信息

- **窗口装饰选项**：
  - 用户名标签显示/隐藏
  - 网络延迟指示器
  - 在线状态指示器

#### **5.2 窗口交互功能**
- **窗口间互动**：
  - 拖拽一只小猫到另一只小猫触发特殊动画
  - 窗口碰撞检测和反应
  - 群体动画同步（所有小猫同时动作）

- **快捷操作**：
  - 双击窗口播放特定动画
  - 快捷键控制所有窗口
  - 一键整理所有窗口布局

## **关键技术问题与解决方案**

### **问题1：窗口数量限制和性能**
**挑战**：
- 每个用户一个窗口，多用户时系统负载大
- Live2D渲染实例过多影响性能

**解决方案**：
- **窗口数量限制**：建议最多8个远程用户窗口
- **性能优化策略**：
  - 不在前台的窗口降低渲染帧率
  - 距离过远的窗口暂停渲染
  - 实现窗口可见性检测
- **资源共享**：相同模型的多个实例共享资源

### **问题2：窗口管理复杂性**
**挑战**：
- 窗口创建/销毁的时序控制
- 窗口状态同步的一致性

**解决方案**：
- **状态机管理**：
```
WindowState: Creating → Loading → Active → Closing → Destroyed
```
- **异步处理**：窗口操作使用异步队列
- **错误恢复**：窗口创建失败时的回退机制
- **状态验证**：定期检查窗口状态一致性

### **问题3：窗口间事件同步**
**挑战**：
- 确保所有窗口接收到正确的事件
- 事件顺序和时序保证

**解决方案**：
- **事件队列机制**：
  - 主窗口维护事件队列
  - 按时间戳排序处理事件
  - 失败重试机制
- **窗口状态跟踪**：
  - 跟踪每个窗口的事件处理状态
  - 实现事件确认机制

### **问题4：用户体验一致性**
**挑战**：
- 多个独立窗口的操作一致性
- 窗口焦点管理

**解决方案**：
- **全局快捷键**：
  - 统一的快捷键控制所有窗口
  - 主窗口作为快捷键分发中心
- **焦点管理策略**：
  - 点击任何窗口不抢夺主窗口焦点
  - 实现窗口组的概念
- **视觉一致性**：
  - 统一的窗口样式和行为
  - 一致的动画和交互反馈

### **问题5：跨平台窗口行为**
**挑战**：
- 不同操作系统的窗口管理差异
- 透明窗口的兼容性问题

**解决方案**：
- **平台适配层**：
  - Windows：处理DWM透明效果
  - macOS：处理窗口层级和透明度
  - Linux：处理不同桌面环境的差异
- **兼容性检测**：
  - 运行时检测系统能力
  - 降级方案处理不支持的特性

## **开发实现顺序**

### **第一阶段：基础多窗口**
1. 实现主窗口和单个远程用户窗口
2. 基础的窗口创建/销毁逻辑
3. 简单的事件分发机制

### **第二阶段：窗口管理**
1. 完整的用户加入/离开处理
2. 窗口状态持久化
3. 错误处理和恢复机制

### **第三阶段：用户体验**
1. 智能窗口布局
2. 窗口个性化功能
3. 性能优化

### **第四阶段：增强功能**
1. 窗口间交互
2. 全局快捷键
3. 高级用户设置

这个多窗口方案的优势：
- **用户体验**：每只小猫独立可拖动，灵活性最高
- **系统集成**：利用操作系统的窗口管理能力
- **扩展性**：易于添加窗口个性化功能
- **性能**：可以针对每个窗口独立优化

主要考虑的是窗口数量控制和系统资源管理，需要在功能丰富度和性能之间找到平衡。