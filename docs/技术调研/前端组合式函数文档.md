# 前端组合式函数文档

## 概述

BongoPet 采用 Vue 3 组合式 API 设计模式，将复杂的业务逻辑封装为可复用的组合式函数（Composables）。这些函数遵循单一职责原则，提供了设备监听、模型管理、窗口控制、系统集成等核心功能。

## 组合式函数架构

```
src/composables/
├── useDevice.ts        # 设备输入监听（键盘、鼠标）
├── useGamepad.ts       # 游戏手柄输入处理
├── useModel.ts         # Live2D模型管理和控制
├── useSharedMenu.ts    # 共享右键菜单逻辑
├── useTauriListen.ts   # Tauri事件监听封装
├── useTauriShortcut.ts # 全局快捷键管理
├── useThemeVars.ts     # 主题变量生成
├── useTray.ts          # 系统托盘管理
└── useWindowState.ts   # 窗口状态持久化
```

## 详细分析

### 1. 设备输入监听 (useDevice.ts)

**职责**: 处理键盘和鼠标输入事件，实现按键可视化

**核心功能**:

```typescript
export function useDevice() {
  const { currentModel } = useModelStore()
  const { handlePress, handleRelease } = useModel()
  
  // 监听模型模式变化，启动/停止设备监听
  watch(() => currentModel?.mode, (mode) => {
    if (mode === 'device') {
      return invoke(INVOKE_KEY.START_DEVICE_LISTING)
    }
    invoke(INVOKE_KEY.STOP_DEVICE_LISTING)
  }, { immediate: true })
  
  // 处理设备事件
  useTauriListen<DeviceEvent>(LISTEN_KEY.DEVICE_CHANGED, ({ payload }) => {
    const { kind, key } = payload
    
    if (kind === 'KeyPress') {
      handlePress(key)
    } else if (kind === 'KeyRelease') {
      handleRelease(key)
    }
  })
}
```

**技术特点**:
- **自动生命周期管理**: 根据模型模式自动启停监听
- **事件类型安全**: 使用 TypeScript 接口定义事件结构
- **与后端集成**: 通过 Tauri invoke 调用 Rust 后端功能

### 2. 游戏手柄处理 (useGamepad.ts)

**职责**: 处理游戏手柄输入，支持摇杆和按键操作

**核心数据结构**:

```typescript
interface StickState {
  x: number
  y: number
  moved: boolean
  pressed: boolean
}

interface Sticks {
  left: StickState
  right: StickState
}
```

**功能实现**:

```typescript
export function useGamepad() {
  const sticks = reactive<Sticks>({
    left: { ...INITIAL_STICK_STATE },
    right: { ...INITIAL_STICK_STATE },
  })
  
  // 计算摇杆激活状态
  const stickActive = computed(() => ({
    left: sticks.left.moved || sticks.left.pressed,
    right: sticks.right.moved || sticks.right.pressed,
  }))
  
  // 监听摇杆状态变化，更新Live2D参数
  watch(sticks.left, ({ x, y, moved, pressed }) => {
    sticks.left.moved = x !== 0 || y !== 0
    live2d.setParameterValue('CatParamStickShowLeftHand', moved || pressed)
  }, { deep: true })
  
  // 处理游戏手柄事件
  useTauriListen<GamepadEvent>(LISTEN_KEY.GAMEPAD_CHANGED, ({ payload }) => {
    const { name, value } = payload
    
    switch (name) {
      case 'LeftStickX':
        sticks.left.x = value
        return handleAxisChange('CatParamStickLX', value)
      case 'LeftStickY':
        sticks.left.y = value
        return handleAxisChange('CatParamStickLY', value)
      // ... 其他摇杆和按键处理
    }
  })
}
```

**技术亮点**:
- **响应式状态管理**: 使用 reactive 管理复杂的摇杆状态
- **计算属性优化**: 通过 computed 计算派生状态
- **深度监听**: 使用 deep watch 监听嵌套对象变化
- **实时参数更新**: 直接操作 Live2D 参数实现实时响应

### 3. Live2D模型管理 (useModel.ts)

**职责**: 管理 Live2D 模型的加载、渲染和交互

**核心功能**:

```typescript
export function useModel() {
  const modelStore = useModelStore()
  const catStore = useCatStore()
  
  // 模型加载
  const loadModel = async (model: Model) => {
    try {
      modelStore.loading = true
      await live2d.loadModel(model.path)
      await live2d.startRender()
    } catch (error) {
      console.error('模型加载失败:', error)
    } finally {
      modelStore.loading = false
    }
  }
  
  // 按键处理
  const handlePress = (key: string) => {
    const keyPath = getKeyImagePath(key)
    if (keyPath && !modelStore.pressedKeys.includes(keyPath)) {
      if (catStore.singleMode) {
        // 单键模式：清除同手的其他按键
        clearSameHandKeys(key)
      }
      modelStore.pressedKeys.push(keyPath)
    }
  }
  
  const handleRelease = (key: string) => {
    const keyPath = getKeyImagePath(key)
    if (keyPath) {
      const index = modelStore.pressedKeys.indexOf(keyPath)
      if (index > -1) {
        modelStore.pressedKeys.splice(index, 1)
      }
    }
  }
  
  // 轴变化处理（摇杆）
  const handleAxisChange = (paramName: string, value: number) => {
    live2d.setParameterValue(paramName, value)
  }
  
  return {
    loadModel,
    handlePress,
    handleRelease,
    handleAxisChange,
  }
}
```

**设计特点**:
- **异步加载管理**: 合理处理模型加载的异步过程
- **错误处理**: 完善的错误捕获和用户反馈
- **状态同步**: 与 Pinia store 紧密集成
- **模式支持**: 支持单键模式和多键模式

### 4. 共享菜单逻辑 (useSharedMenu.ts)

**职责**: 提供右键菜单和托盘菜单的共享逻辑

**菜单生成**:

```typescript
export function useSharedMenu() {
  const catStore = useCatStore()
  
  // 缩放菜单项生成
  const getScaleMenuItems = async () => {
    const options = range(50, 151, 25) // [50, 75, 100, 125, 150]
    
    const items = options.map((item) => {
      return CheckMenuItem.new({
        text: item === 100 ? '默认' : `${item}%`,
        checked: catStore.scale === item,
        action: () => {
          catStore.scale = item
        },
      })
    })
    
    // 如果当前缩放不在预设选项中，添加自定义选项
    if (!options.includes(catStore.scale)) {
      items.unshift(CheckMenuItem.new({
        text: `${catStore.scale}%`,
        checked: true,
        enabled: false,
      }))
    }
    
    return Promise.all(items)
  }
  
  // 透明度菜单项生成
  const getOpacityMenuItems = async () => {
    const options = range(25, 101, 25) // [25, 50, 75, 100]
    
    const items = options.map((item) => {
      return CheckMenuItem.new({
        text: `${item}%`,
        checked: catStore.opacity === item,
        action: () => {
          catStore.opacity = item
        },
      })
    })
    
    return Promise.all(items)
  }
  
  // 完整菜单构建
  const getSharedMenu = async () => {
    return [
      MenuItem.new({
        text: catStore.visible ? '隐藏猫咪' : '显示猫咪',
        action: () => {
          catStore.visible = !catStore.visible
        },
      }),
      await Submenu.new({
        text: '缩放',
        items: await getScaleMenuItems(),
      }),
      await Submenu.new({
        text: '透明度',
        items: await getOpacityMenuItems(),
      }),
      // ... 更多菜单项
    ]
  }
  
  return {
    getSharedMenu,
  }
}
```

**技术特点**:
- **动态菜单生成**: 根据当前状态动态生成菜单项
- **状态同步**: 菜单项状态与应用状态实时同步
- **可复用设计**: 同时支持右键菜单和托盘菜单
- **用户体验**: 支持自定义值显示和禁用状态

### 5. Tauri事件监听封装 (useTauriListen.ts)

**职责**: 封装 Tauri 事件监听，提供 Vue 生命周期集成

```typescript
export function useTauriListen<T>(...args: Parameters<typeof listen<T>>) {
  const unlisten = ref(noop)
  
  onMounted(async () => {
    unlisten.value = await listen<T>(...args)
  })
  
  onUnmounted(() => {
    unlisten.value()
  })
}
```

**设计优势**:
- **自动生命周期管理**: 组件挂载时注册，卸载时清理
- **类型安全**: 支持泛型，提供完整的类型推导
- **简化使用**: 一行代码即可实现事件监听
- **内存安全**: 防止内存泄漏

### 6. 全局快捷键管理 (useTauriShortcut.ts)

**职责**: 管理系统级全局快捷键的注册和注销

```typescript
export function useTauriShortcut(shortcut: Ref<string, string>, callback: ShortcutHandler) {
  const oldShortcut = ref(shortcut.value)
  
  watch(shortcut, async (value) => {
    // 注销旧快捷键
    if (oldShortcut.value) {
      const registered = await isRegistered(oldShortcut.value)
      if (registered) {
        await unregister(oldShortcut.value)
      }
    }
    
    // 注册新快捷键
    if (!value) return
    
    await register(value, (event) => {
      if (event.state === 'Released') return
      callback(event)
    })
    
    oldShortcut.value = value
  }, { immediate: true })
}
```

**功能特点**:
- **动态更新**: 支持快捷键的动态修改
- **冲突处理**: 自动处理快捷键冲突和重复注册
- **状态过滤**: 只响应按键按下事件，忽略释放事件
- **响应式集成**: 与 Vue 响应式系统无缝集成

### 7. 主题变量生成 (useThemeVars.ts)

**职责**: 生成 Ant Design Vue 主题的 CSS 变量

```typescript
export function useThemeVars() {
  const { defaultAlgorithm, darkAlgorithm, defaultConfig } = theme
  
  const generateColorVars = () => {
    const { token } = defaultConfig
    
    const colors = [
      defaultAlgorithm(token),
      darkAlgorithm(token),
    ]
    
    for (const [index, item] of colors.entries()) {
      const isDark = index !== 0
      const vars: Record<string, any> = {}
      
      // 转换为 CSS 变量格式
      for (const [key, value] of Object.entries(item)) {
        vars[`--ant-${kebabCase(key)}`] = value
      }
      
      // 创建样式标签
      const style = document.createElement('style')
      style.dataset.theme = isDark ? 'dark' : 'light'
      const selector = isDark ? 'html.dark' : ':root'
      const values = Object.entries(vars).map(([key, value]) => `${key}: ${value};`)
      
      style.innerHTML = `${selector}{\n${values.join('\n')}\n}`
      document.head.appendChild(style)
    }
  }
  
  return {
    generateColorVars,
  }
}
```

**技术实现**:
- **主题算法**: 使用 Ant Design 的主题算法生成颜色
- **CSS 变量**: 动态生成 CSS 自定义属性
- **命名转换**: 使用 kebab-case 转换变量名
- **选择器区分**: 为亮色和暗色主题使用不同选择器

### 8. 系统托盘管理 (useTray.ts)

**职责**: 管理系统托盘图标和菜单

```typescript
export function useTray() {
  const catStore = useCatStore()
  const { getSharedMenu } = useSharedMenu()
  
  // 监听状态变化，更新托盘菜单
  watch([() => catStore.visible, () => catStore.penetrable], () => {
    updateTrayMenu()
  })
  
  // 防抖更新（缩放和透明度变化频繁）
  watchDebounced([() => catStore.scale, () => catStore.opacity], () => {
    updateTrayMenu()
  }, { debounce: 200 })
  
  const createTray = async () => {
    const tray = await getTrayById()
    if (tray) return
    
    const appName = await getName()
    const appVersion = await getVersion()
    const menu = await getTrayMenu()
    
    // 根据平台选择图标
    const path = isMac ? 'assets/tray-mac.png' : 'assets/tray.png'
    const icon = await resolveResource(path)
    
    const options: TrayIconOptions = {
      menu,
      icon,
      tooltip: `${appName} v${appVersion}`,
      action: (event) => {
        if (event.clickType === 'Left') {
          catStore.visible = !catStore.visible
        }
      },
    }
    
    await TrayIcon.new(options)
  }
  
  return {
    createTray,
  }
}
```

**功能特点**:
- **跨平台支持**: 根据操作系统选择合适的图标
- **智能更新**: 使用防抖优化频繁的菜单更新
- **交互支持**: 支持左键点击切换显示状态
- **状态同步**: 托盘菜单与应用状态实时同步

### 9. 窗口状态持久化 (useWindowState.ts)

**职责**: 管理窗口位置和大小的持久化

```typescript
export function useWindowState() {
  const appStore = useAppStore()
  const isRestored = ref(false)
  
  onMounted(() => {
    appWindow.onMoved(onChange)
    appWindow.onResized(onChange)
  })
  
  // 窗口状态变化处理
  const onChange = async (event: Event<PhysicalPosition | PhysicalSize>) => {
    const minimized = await appWindow.isMinimized()
    if (minimized) return // 忽略最小化状态的变化
    
    appStore.windowState[label] ??= {}
    Object.assign(appStore.windowState[label], event.payload)
  }
  
  // 恢复窗口状态
  const restoreState = async () => {
    const { x, y, width, height } = appStore.windowState[label] ?? {}
    
    if (isNumber(x) && isNumber(y)) {
      // 检查位置是否在有效的显示器范围内
      const monitors = await availableMonitors()
      const monitor = monitors.find((monitor) => {
        const { position, size } = monitor
        const inBoundsX = x >= position.x && x <= position.x + size.width
        const inBoundsY = y >= position.y && y <= position.y + size.height
        return inBoundsX && inBoundsY
      })
      
      if (monitor) {
        await appWindow.setPosition(new PhysicalPosition(x, y))
      }
    }
    
    if (isNumber(width) && isNumber(height)) {
      await appWindow.setSize(new PhysicalSize(width, height))
    }
    
    isRestored.value = true
  }
  
  return {
    restoreState,
    isRestored,
  }
}
```

**技术特点**:
- **多显示器支持**: 检查窗口位置是否在有效显示器范围内
- **状态过滤**: 忽略最小化状态的位置变化
- **类型安全**: 使用类型检查确保数据有效性
- **恢复标记**: 提供恢复完成状态供其他组件使用

## 设计模式和最佳实践

### 1. 单一职责原则

每个组合式函数都有明确的职责边界：
- `useDevice`: 专注于设备输入处理
- `useModel`: 专注于模型管理
- `useTray`: 专注于系统托盘功能

### 2. 组合优于继承

通过组合多个小的组合式函数实现复杂功能：

```typescript
// 在组件中组合使用
export default defineComponent({
  setup() {
    useDevice()    // 设备监听
    useGamepad()   // 游戏手柄
    useModel()     // 模型管理
    useTray()      // 系统托盘
    
    // 组件特定逻辑
    return {}
  }
})
```

### 3. 响应式设计

充分利用 Vue 3 响应式系统：

```typescript
// 使用 watch 监听状态变化
watch(() => store.value, (newValue) => {
  // 执行副作用
})

// 使用 computed 计算派生状态
const derived = computed(() => {
  return store.value * 2
})
```

### 4. 类型安全

使用 TypeScript 提供完整的类型支持：

```typescript
// 定义事件类型
interface DeviceEvent {
  kind: 'KeyPress' | 'KeyRelease'
  key: string
}

// 泛型函数
function useTauriListen<T>(eventName: string, handler: (event: T) => void) {
  // 实现
}
```

### 5. 生命周期管理

合理管理资源的创建和销毁：

```typescript
export function useResource() {
  const resource = ref(null)
  
  onMounted(async () => {
    resource.value = await createResource()
  })
  
  onUnmounted(() => {
    resource.value?.destroy()
  })
  
  return { resource }
}
```

## 性能优化策略

### 1. 防抖和节流

对于频繁触发的事件使用防抖：

```typescript
watchDebounced([() => catStore.scale, () => catStore.opacity], () => {
  updateTrayMenu()
}, { debounce: 200 })
```

### 2. 条件监听

根据条件启停监听，避免不必要的资源消耗：

```typescript
watch(() => currentModel?.mode, (mode) => {
  if (mode === 'device') {
    startListening()
  } else {
    stopListening()
  }
})
```

### 3. 计算属性缓存

利用计算属性的缓存特性：

```typescript
const stickActive = computed(() => ({
  left: sticks.left.moved || sticks.left.pressed,
  right: sticks.right.moved || sticks.right.pressed,
}))
```

## 错误处理和调试

### 1. 异步错误处理

```typescript
const loadModel = async (model: Model) => {
  try {
    modelStore.loading = true
    await live2d.loadModel(model.path)
  } catch (error) {
    console.error('模型加载失败:', error)
    // 用户友好的错误提示
    message.error('模型加载失败，请检查文件是否完整')
  } finally {
    modelStore.loading = false
  }
}
```

### 2. 开发调试支持

```typescript
// 开发环境下的调试信息
if (import.meta.env.DEV) {
  watch(() => catStore.scale, (newValue, oldValue) => {
    console.log(`缩放变化: ${oldValue} -> ${newValue}`)
  })
}
```

## 扩展建议

### 1. 新增组合式函数

创建新的组合式函数时，遵循以下模式：

```typescript
export function useNewFeature() {
  // 状态定义
  const state = ref(initialValue)
  
  // 计算属性
  const computed = computed(() => {
    // 计算逻辑
  })
  
  // 方法定义
  const method = () => {
    // 方法实现
  }
  
  // 生命周期处理
  onMounted(() => {
    // 初始化逻辑
  })
  
  onUnmounted(() => {
    // 清理逻辑
  })
  
  return {
    state,
    computed,
    method,
  }
}
```

### 2. 功能组合

对于复杂功能，可以组合多个组合式函数：

```typescript
export function useComplexFeature() {
  const device = useDevice()
  const model = useModel()
  const tray = useTray()
  
  // 组合逻辑
  const combinedLogic = () => {
    // 使用多个组合式函数的功能
  }
  
  return {
    ...device,
    ...model,
    ...tray,
    combinedLogic,
  }
}
```

## 总结

BongoPet 的组合式函数系统具有以下特点：

1. **模块化设计**: 每个函数职责单一，易于理解和维护
2. **响应式集成**: 与 Vue 3 响应式系统深度集成
3. **类型安全**: 完整的 TypeScript 类型支持
4. **生命周期管理**: 自动处理资源的创建和销毁
5. **性能优化**: 合理使用防抖、计算属性等优化策略
6. **错误处理**: 完善的异步错误处理机制
7. **可扩展性**: 支持功能组合和扩展

这种设计为应用提供了灵活、高效、易维护的业务逻辑层。