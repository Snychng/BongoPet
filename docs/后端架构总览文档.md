# 后端架构总览文档

## 概述

BongoPet 后端基于 Tauri 2.0 框架构建，使用 Rust 语言实现跨平台桌面应用的核心功能。后端负责系统级操作、设备监听、文件管理、窗口控制等底层功能，为前端提供稳定可靠的 API 接口。

## 技术栈

### 核心框架
- **Tauri 2.0**: 现代化的桌面应用开发框架
- **Rust 2024 Edition**: 系统级编程语言，提供内存安全和高性能
- **Serde**: JSON 序列化/反序列化库
- **Tokio**: 异步运行时（通过 Tauri 集成）

### 系统集成库
- **rdev**: 跨平台设备输入监听（键盘、鼠标）
- **gilrs**: 游戏手柄输入处理库
- **fs_extra**: 增强的文件系统操作
- **tauri-nspanel**: macOS 特定的窗口管理

### Tauri 插件生态
- **tauri-plugin-os**: 操作系统信息获取
- **tauri-plugin-process**: 进程管理
- **tauri-plugin-opener**: 文件/URL 打开
- **tauri-plugin-pinia**: Pinia 状态持久化
- **tauri-plugin-log**: 日志系统
- **tauri-plugin-updater**: 自动更新
- **tauri-plugin-autostart**: 开机自启动
- **tauri-plugin-global-shortcut**: 全局快捷键
- **tauri-plugin-dialog**: 系统对话框
- **tauri-plugin-fs**: 文件系统访问
- **tauri-plugin-clipboard-manager**: 剪贴板管理

## 项目结构

```
src-tauri/
├── Cargo.toml              # 项目配置和依赖管理
├── build.rs                 # 构建脚本
├── tauri.conf.json          # Tauri 主配置文件
├── tauri.*.conf.json        # 平台特定配置
├── capabilities/            # 权限配置
│   └── default.json         # 默认权限集
├── assets/                  # 静态资源
│   ├── models/              # Live2D 模型资源
│   ├── *.png                # 应用图标和托盘图标
│   └── BongoCat.desktop     # Linux 桌面文件
└── src/                     # 源代码目录
    ├── main.rs              # 应用入口点
    ├── lib.rs               # 库入口和应用配置
    ├── core/                # 核心功能模块
    │   ├── device.rs        # 设备输入监听
    │   ├── gamepad.rs       # 游戏手柄处理
    │   ├── prevent_default.rs # 默认行为阻止
    │   └── setup/           # 平台特定初始化
    ├── plugins/             # 自定义插件
    │   └── window/          # 窗口管理插件
    └── utils/               # 工具函数
        └── fs_extra.rs      # 文件系统扩展
```

## 核心架构设计

### 1. 应用入口 (main.rs)

```rust
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
    bongo_cat_lib::run()
}
```

**设计特点**:
- **条件编译**: 发布版本隐藏控制台窗口
- **库分离**: 主逻辑在 lib.rs 中实现，便于测试和模块化

### 2. 应用配置 (lib.rs)

**核心功能**:

```rust
pub fn run() {
    let app = tauri::Builder::default()
        .setup(|app| {
            // 获取窗口句柄
            let main_window = app.get_webview_window(MAIN_WINDOW_LABEL).unwrap();
            let preference_window = app.get_webview_window(PREFERENCE_WINDOW_LABEL).unwrap();
            
            // 平台特定初始化
            setup::default(&app_handle, main_window.clone(), preference_window.clone());
            
            Ok(())
        })
        .invoke_handler(generate_handler![
            copy_dir,
            start_device_listening,
            start_gamepad_listing,
            stop_gamepad_listing
        ])
        // 插件注册
        .plugin(tauri_plugin_custom_window::init())
        .plugin(tauri_plugin_os::init())
        // ... 更多插件
        .on_window_event(|window, event| {
            match event {
                WindowEvent::CloseRequested { api, .. } => {
                    let _ = window.hide();
                    api.prevent_close();
                }
                _ => {}
            }
        })
        .build(tauri::generate_context!())
        .expect("error while running tauri application");
    
    app.run(|app_handle, event| {
        match event {
            #[cfg(target_os = "macos")]
            tauri::RunEvent::Reopen { .. } => {
                show_preference_window(app_handle);
            }
            _ => {}
        }
    });
}
```

**架构特点**:
- **插件化架构**: 通过插件系统扩展功能
- **命令注册**: 注册可从前端调用的 Rust 函数
- **事件处理**: 处理窗口和应用级事件
- **平台适配**: 支持 macOS 特定的重新打开行为

### 3. 配置管理 (tauri.conf.json)

**应用配置**:

```json
{
  "productName": "BongoCat",
  "identifier": "com.ayangweb.BongoCat",
  "app": {
    "macOSPrivateApi": true,
    "windows": [
      {
        "label": "main",
        "title": "BongoCat",
        "shadow": false,
        "alwaysOnTop": true,
        "transparent": true,
        "decorations": false,
        "acceptFirstMouse": true,
        "skipTaskbar": true
      },
      {
        "label": "preference",
        "title": "偏好设置",
        "visible": false,
        "titleBarStyle": "Overlay",
        "minWidth": 800,
        "minHeight": 600
      }
    ]
  }
}
```

**配置特点**:
- **双窗口设计**: 主窗口（透明悬浮）+ 设置窗口（传统界面）
- **窗口属性**: 支持透明、置顶、无边框等特殊属性
- **平台特性**: 启用 macOS 私有 API 以获得更好的系统集成
- **安全配置**: 资源协议和 CSP 配置

### 4. 权限管理 (capabilities/default.json)

**权限配置**:

```json
{
  "permissions": [
    "core:default",
    "core:window:allow-start-dragging",
    "core:window:allow-set-always-on-top",
    "fs:read-all",
    "fs:write-all",
    "global-shortcut:allow-register",
    "global-shortcut:allow-unregister"
  ]
}
```

**安全特点**:
- **最小权限原则**: 只授予必要的系统权限
- **细粒度控制**: 精确控制每个功能的权限范围
- **文件系统访问**: 支持模型文件的读写操作
- **全局快捷键**: 支持系统级快捷键注册

## 核心模块详解

### 1. 设备监听模块 (core/device.rs)

**功能职责**: 监听键盘和鼠标输入事件

**数据结构**:

```rust
#[derive(Debug, Clone, Serialize)]
pub enum DeviceEventKind {
    MousePress,
    MouseRelease,
    MouseMove,
    KeyboardPress,
    KeyboardRelease,
}

#[derive(Debug, Clone, Serialize)]
pub struct DeviceEvent {
    kind: DeviceEventKind,
    value: Value,
}
```

**核心实现**:

```rust
#[command]
pub async fn start_device_listening<R: Runtime>(app_handle: AppHandle<R>) -> Result<(), String> {
    if IS_LISTENING.load(Ordering::SeqCst) {
        return Ok(());
    }
    
    IS_LISTENING.store(true, Ordering::SeqCst);
    
    let callback = move |event: Event| {
        let device_event = match event.event_type {
            EventType::KeyPress(key) => DeviceEvent {
                kind: DeviceEventKind::KeyboardPress,
                value: json!(format!("{:?}", key)),
            },
            EventType::KeyRelease(key) => DeviceEvent {
                kind: DeviceEventKind::KeyboardRelease,
                value: json!(format!("{:?}", key)),
            },
            // ... 其他事件类型
            _ => return,
        };
        
        let _ = app_handle.emit("device-changed", device_event);
    };
    
    listen(callback).map_err(|err| format!("Failed to listen device: {:?}", err))?;
    
    Ok(())
}
```

**技术特点**:
- **原子操作**: 使用 AtomicBool 确保线程安全的状态管理
- **事件发射**: 通过 Tauri 事件系统向前端发送设备事件
- **错误处理**: 完善的错误捕获和转换机制
- **跨平台支持**: 基于 rdev 库实现跨平台设备监听

### 2. 游戏手柄模块 (core/gamepad.rs)

**功能职责**: 处理游戏手柄输入和状态管理

**数据结构**:

```rust
#[derive(Debug, Clone, Serialize)]
pub enum GamepadEventKind {
    ButtonChanged,
    AxisChanged,
}

#[derive(Debug, Clone, Serialize)]
pub struct GamepadEvent {
    kind: GamepadEventKind,
    name: String,
    value: f32,
}
```

**核心实现**:

```rust
#[command]
pub async fn start_gamepad_listing<R: Runtime>(app_handle: AppHandle<R>) -> Result<(), String> {
    if IS_LISTENING.load(Ordering::SeqCst) {
        return Ok(());
    }
    
    IS_LISTENING.store(true, Ordering::SeqCst);
    
    let mut gilrs = Gilrs::new().map_err(|err| err.to_string())?;
    
    while IS_LISTENING.load(Ordering::SeqCst) {
        while let Some(event) = gilrs.next_event() {
            let gamepad_event = match event.event {
                EventType::ButtonChanged(button, value, ..) => GamepadEvent {
                    kind: GamepadEventKind::ButtonChanged,
                    name: format!("{:?}", button),
                    value,
                },
                EventType::AxisChanged(axis, value, ..) => GamepadEvent {
                    kind: GamepadEventKind::AxisChanged,
                    name: format!("{:?}", axis),
                    value,
                },
                _ => continue,
            };
            
            let _ = app_handle.emit("gamepad-changed", gamepad_event);
        }
    }
    
    Ok(())
}
```

**技术特点**:
- **实时监听**: 持续轮询游戏手柄状态变化
- **精确数据**: 支持按键和摇杆的精确数值传输
- **可控制**: 支持动态启停监听功能
- **高性能**: 基于 gilrs 库的高效实现

### 3. 平台适配模块 (core/setup/)

**架构设计**: 使用条件编译实现平台特定功能

**macOS 特定实现** (setup/macos.rs):

```rust
pub fn platform(
    app_handle: &AppHandle,
    main_window: WebviewWindow,
    _preference_window: WebviewWindow,
) {
    // 初始化 NSPanel 插件
    let _ = app_handle.plugin(tauri_nspanel::init());
    
    // 隐藏 Dock 图标
    let _ = app_handle.set_dock_visibility(false);
    
    // 转换为 NSPanel
    let panel = main_window.to_panel().unwrap();
    
    // 设置窗口样式
    panel.set_style_mask(NSWindowStyleMaskNonActivatingPanel | NSResizableWindowMask);
    
    // 设置窗口行为
    panel.set_collection_behaviour(
        NSWindowCollectionBehavior::NSWindowCollectionBehaviorCanJoinAllSpaces
            | NSWindowCollectionBehavior::NSWindowCollectionBehaviorStationary
            | NSWindowCollectionBehavior::NSWindowCollectionBehaviorFullScreenAuxiliary,
    );
    
    // 设置窗口代理
    let delegate = panel_delegate!(EcoPanelDelegate {
        window_did_become_key,
        window_did_resign_key,
        window_did_resize,
        window_did_move
    });
}
```

**通用实现** (setup/common.rs):

```rust
pub fn platform(
    _app_handle: &AppHandle,
    _main_window: WebviewWindow,
    _preference_window: WebviewWindow,
) {
    // 其他平台暂无特殊处理
}
```

**设计特点**:
- **条件编译**: 根据目标平台编译不同的实现
- **macOS 优化**: 利用 NSPanel 实现更好的桌面宠物体验
- **窗口行为**: 精确控制窗口在不同空间和全屏模式下的行为
- **事件代理**: 监听窗口焦点、移动、调整大小等事件

### 4. 自定义插件系统 (plugins/window/)

**插件架构**:

```rust
pub fn init<R: Runtime>() -> TauriPlugin<R> {
    Builder::new("custom-window")
        .invoke_handler(generate_handler![
            commands::show_window,
            commands::hide_window,
            commands::set_always_on_top,
            commands::set_taskbar_visibility,
        ])
        .build()
}
```

**命令实现**:

```rust
pub static MAIN_WINDOW_LABEL: &str = "main";
pub static PREFERENCE_WINDOW_LABEL: &str = "preference";

fn shared_show_window<R: Runtime>(_app_handle: &AppHandle<R>, window: &WebviewWindow<R>) {
    let _ = window.show();
    let _ = window.unminimize();
    let _ = window.set_focus();
}

fn shared_set_always_on_top<R: Runtime>(
    _app_handle: &AppHandle<R>,
    window: &WebviewWindow<R>,
    always_on_top: bool,
) {
    if always_on_top {
        let _ = window.set_always_on_bottom(false);
        let _ = window.set_always_on_top(true);
    } else {
        let _ = window.set_always_on_top(false);
        let _ = window.set_always_on_bottom(true);
    }
}
```

**插件特点**:
- **模块化设计**: 独立的 Cargo 项目，可复用
- **平台适配**: 支持不同平台的窗口管理差异
- **状态管理**: 智能处理窗口的显示、隐藏、置顶等状态
- **错误容忍**: 使用 `let _ =` 模式忽略非关键错误

### 5. 工具模块 (utils/)

**文件系统扩展** (utils/fs_extra.rs):

```rust
#[command]
pub async fn copy_dir(from_path: String, to_path: String) -> Result<(), String> {
    let mut options = CopyOptions::new();
    options.content_only = true;
    
    create_dir_all(&to_path).map_err(|err| err.to_string())?;
    
    copy(from_path, to_path, &options).map_err(|err| err.to_string())?;
    
    Ok(())
}
```

**工具特点**:
- **异步支持**: 使用 async/await 避免阻塞主线程
- **错误转换**: 将系统错误转换为字符串便于前端处理
- **目录创建**: 自动创建目标目录
- **内容复制**: 只复制目录内容，不复制目录本身

## 构建和部署

### 1. 构建配置 (Cargo.toml)

**项目元信息**:

```toml
[package]
name = "bongo-cat"
version = "0.7.1"
description = "A Tauri App"
authors = ["ayangweb"]
edition = "2024"

[lib]
name = "bongo_cat_lib"
crate-type = ["staticlib", "cdylib", "rlib"]
```

**依赖管理**:

```toml
[dependencies]
tauri = { workspace = true, features = ["tray-icon", "protocol-asset", "macos-private-api", "image-png"] }
rdev = { git = "https://github.com/kunkunsh/rdev" }
gilrs = { git = "https://github.com/ayangweb/gilrs", default-features = false, features = ["xinput"] }

[target."cfg(target_os = \"macos\")".dependencies]
tauri-nspanel.workspace = true
```

**构建特点**:
- **工作空间**: 使用 workspace 管理依赖版本
- **特性选择**: 精确控制 Tauri 功能特性
- **平台依赖**: 条件编译平台特定依赖
- **Git 依赖**: 使用 fork 版本解决特定问题

### 2. 构建脚本 (build.rs)

```rust
fn main() {
    tauri_build::build()
}
```

**构建流程**:
- **资源嵌入**: 将前端资源嵌入到二进制文件
- **权限生成**: 根据配置生成权限检查代码
- **平台适配**: 处理不同平台的构建差异

### 3. 打包配置

**多平台支持**:

```json
{
  "bundle": {
    "targets": ["nsis", "dmg", "app", "appimage", "deb", "rpm"],
    "category": "Game",
    "createUpdaterArtifacts": true,
    "resources": ["assets/tray.png", "assets/models"]
  }
}
```

**更新机制**:

```json
{
  "plugins": {
    "updater": {
      "endpoints": [
        "http://api.upgrade.toolsetlink.com/v1/tauri/upgrade",
        "https://gh-proxy.com/github.com/ayangweb/BongoCat/releases/latest/download/latest.json"
      ]
    }
  }
}
```

## 性能优化策略

### 1. 内存管理

- **零拷贝**: 使用引用和借用避免不必要的数据复制
- **原子操作**: 使用 AtomicBool 实现无锁的状态管理
- **资源释放**: 及时释放不再使用的资源

### 2. 并发处理

- **异步命令**: 所有 Tauri 命令都是异步的，避免阻塞
- **事件驱动**: 使用事件系统实现松耦合的模块通信
- **线程安全**: 使用 Rust 的所有权系统保证线程安全

### 3. 系统集成

- **原生 API**: 在 macOS 上使用 NSPanel 获得更好的性能
- **最小权限**: 只请求必要的系统权限
- **资源优化**: 合理管理系统资源的使用

## 安全机制

### 1. 权限控制

- **细粒度权限**: 精确控制每个功能的权限范围
- **最小权限原则**: 只授予必要的系统访问权限
- **动态检查**: 运行时检查权限有效性

### 2. 数据安全

- **类型安全**: Rust 的类型系统防止内存安全问题
- **序列化安全**: 使用 Serde 确保数据序列化的安全性
- **错误处理**: 完善的错误处理机制防止崩溃

### 3. 通信安全

- **事件验证**: 验证前后端通信的事件格式
- **命令授权**: 只有授权的命令才能被前端调用
- **资源保护**: 保护敏感系统资源的访问

## 调试和监控

### 1. 日志系统

```rust
.plugin(
    tauri_plugin_log::Builder::new()
        .timezone_strategy(tauri_plugin_log::TimezoneStrategy::UseLocal)
        .filter(|metadata| !metadata.target().contains("gilrs"))
        .build(),
)
```

**日志特点**:
- **时区支持**: 使用本地时区显示日志时间
- **过滤机制**: 过滤掉噪音日志（如 gilrs 库的调试信息）
- **分级记录**: 支持不同级别的日志记录

### 2. 开发工具

```rust
// #[cfg(debug_assertions)]
// main_window.open_devtools();
```

**调试支持**:
- **开发者工具**: 在调试模式下可启用 WebView 开发者工具
- **条件编译**: 调试功能只在开发环境启用
- **热重载**: 支持前端代码的热重载

## 扩展建议

### 1. 新增功能模块

创建新的核心模块时，遵循以下模式：

```rust
// src/core/new_feature.rs
use std::sync::atomic::{AtomicBool, Ordering};
use tauri::{AppHandle, Emitter, Runtime, command};
use serde::Serialize;

#[derive(Debug, Clone, Serialize)]
pub struct NewFeatureEvent {
    // 事件数据结构
}

static IS_ACTIVE: AtomicBool = AtomicBool::new(false);

#[command]
pub async fn start_new_feature<R: Runtime>(app_handle: AppHandle<R>) -> Result<(), String> {
    // 功能实现
    Ok(())
}

#[command]
pub async fn stop_new_feature() {
    IS_ACTIVE.store(false, Ordering::SeqCst);
}
```

### 2. 自定义插件开发

创建新插件的步骤：

1. 在 `src/plugins/` 下创建新目录
2. 添加 `Cargo.toml` 配置文件
3. 实现插件逻辑和命令
4. 在主应用中注册插件

### 3. 平台特定功能

添加平台特定功能：

```rust
#[cfg(target_os = "windows")]
mod windows_specific;

#[cfg(target_os = "linux")]
mod linux_specific;

#[cfg(target_os = "macos")]
mod macos_specific;
```

## 总结

BongoPet 后端架构具有以下特点：

1. **现代化技术栈**: 基于 Tauri 2.0 和 Rust 2024 Edition
2. **模块化设计**: 清晰的模块划分和职责分离
3. **跨平台支持**: 统一的 API 接口，平台特定的优化实现
4. **插件化架构**: 可扩展的插件系统
5. **性能优化**: 异步处理、零拷贝、原子操作
6. **安全可靠**: 完善的权限控制和错误处理
7. **易于维护**: 清晰的代码结构和文档
8. **开发友好**: 完善的调试工具和日志系统

这种架构为桌面宠物应用提供了稳定、高效、安全的后端支持，同时保持了良好的可扩展性和可维护性。